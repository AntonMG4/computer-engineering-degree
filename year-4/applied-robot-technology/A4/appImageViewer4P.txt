#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# ../ELE610/py3/appImageViewer4.py    (disk)
#
#  Extends appImageViewer2 by adding some more functionality using heritage.
#  Some (skeleton) methods for locating disc in image and finding the
#  angle for rotation to estimate disk speed.
#  Disk menu has actions for: locating disc, finding read sector and its angle, ...
#
# Karl Skretting, UiS, November 2020, June 2022

# Example on how to use file:
# (C:\...\Anaconda3) C:\..\py3> activate py38
# (py38) C:\..\py3> python appImageViewer4.py
# (py38) C:\..\py3> python appImageViewer4.py DarkCrop10ms.bmp

_appFileName = "appImageViewer4P"
_author = "Karl Skretting, UiS" 
_version = "2022.06.27"

import sys
import os.path
#from math import hypot, pi, atan2, cos, sin    # sqrt, cos, sin, tan, log, ceil, floor 
import numpy as np
import cv2

from findAngle import calculate_relative_angle

try:
	from PyQt5.QtCore import Qt, QPoint, QT_VERSION_STR  
	from PyQt5.QtGui import QImage, QPixmap, QTransform, QColor
	from PyQt5.QtWidgets import (QApplication, QAction, QFileDialog, QLabel, 
			QGraphicsPixmapItem, QInputDialog)  # QColorDialog, 
except ImportError:
	raise ImportError( f"{_appFileName}: Requires PyQt5." )
#end try, import PyQt5 classes 

from appImageViewer2 import myPath, MainWindow as inheritedMainWindow 

class MainWindow(inheritedMainWindow):  
	"""MainWindow class for this image viewer is inherited from another image viewer."""
	
# Two initialization methods used when an object is created
	def __init__(self, fName="", parent=None):
		# print( f"File {_appFileName}: (debug) first line in __init__()" ) 
		super().__init__(fName, parent)# use inherited __init__ with extension as follows
		#
		# set appFileName as it should be, it is set wrong in super()...
		self.appFileName = _appFileName 
		if (not self.pixmap.isNull()): 
			self.setWindowTitle( f"{self.appFileName} : {fName}" ) 
		else:
			self.setWindowTitle(self.appFileName)
		# 
		# self.view.rubberBandRectGiven.connect(self.methodUsingRubberbandEnd)  
		# # signal is already connected to cropEnd (appImageViewer1), and can be connected to more
		# self.methodUsingRubberbandActive = False    # using this to check if rubber band is to be used here
		#
		self.initMenu4()
		self.setMenuItems4()
		# print( f"File {_appFileName}: (debug) last line in __init__()" )
		return
	#end function __init__
	
	def initMenu4(self):
		"""Initialize Disk menu."""
		# print( f"File {_appFileName}: (debug) first line in initMenu4()" )
		a = self.qaFindDisk = QAction('Find disk', self)
		a.triggered.connect(self.findDisk)
		a.setToolTip("Find disk using cv2.HoughCircles (TODO)")
		a = self.qaFindRedSector = QAction('Find red sector', self)
		a.triggered.connect(self.findRedSector)
		a.setToolTip("Find angle for red sector center (TODO)")
		a = self.qaFindSpeed = QAction('Find speed', self)
		a.triggered.connect(self.findSpeed)
		a.setToolTip("Find speed for rotating disk (TODO)")
		#
		a = self.qaFindAngle = QAction('Find Angle', self)
		a.triggered.connect(self.find_angle)
		#
		a = self.qaFindDiskCenter = QAction('Find Disk Center', self)
		a.triggered.connect(self.find_disk_center)
		#
		diskMenu = self.mainMenu.addMenu("Disk")
		diskMenu.addAction(self.qaFindDisk)
		diskMenu.addAction(self.qaFindRedSector)
		diskMenu.addAction(self.qaFindSpeed)
		diskMenu.addAction(self.qaFindAngle)
		diskMenu.addAction(self.qaFindDiskCenter)
		diskMenu.setToolTipsVisible(True)
		return
	#end function initMenu4
	
# Some methods that may be used by several of the menu actions
	def setMenuItems4(self):
		"""Enable/disable menu items as appropriate."""
		pixmapOK = ((not self.pixmap.isNull()) and isinstance(self.curItem, QGraphicsPixmapItem))
		#
		#self.qaFindDisk.setEnabled(pixmapOK)   
		#self.qaFindDisk.setEnabled(pixmapOK)   
		#self.qaFindDisk.setEnabled(pixmapOK)
		return
		
# Methods for actions on the Disk-menu
	def findDisk(self):
		"""Find the large disk in the center of the image using ??."""
		#
		# -- your code may be written in between the comment lines below --
		# find a large circle using HoughCircles
		# perhaps locate center better by locating black center more exact
		# print results, or indicate it on image
		#

		gray_image = cv2.cvtColor(self.npImage, cv2.COLOR_BGR2GRAY)
		
		C = cv2.HoughCircles(gray_image, cv2.HOUGH_GRADIENT, dp=1.2, minDist=100, param1=100, param2=21, minRadius=20, maxRadius=25)
		
		if C is not None:
				C = np.int16(np.around(C))
				for i in range(min(20, C.shape[1])):
					(x,y,r) = ( C[0,i,0], C[0,i,1], C[0,i,2] )  # center and radius
					cv2.circle(self.npImage, (x,y), 1, (0, 100, 100), 3)  # indicate center 
					cv2.circle(self.npImage, (x,y), r, (0, 255, 255), 3) # and circle outline
		
		self.np2image2pixmap(self.npImage, numpyAlso=True)
	
	def find_angle(self):
		# Load the two images
		image1 = cv2.imread('disk_initial.jpg')
		image2 = cv2.imread('speed_50ms.jpg')

		# Calculate the angle between the two images
		relative_angle, image1_with_line, image2_with_line = calculate_relative_angle(image1, image2)

		# Show the images with the angle lines
		cv2.imshow("Image 1 with Angle Line", image1_with_line)
		cv2.imshow("Image 2 with Angle Line", image2_with_line)
		cv2.waitKey(0)
		cv2.destroyAllWindows()

		if relative_angle is not None:
			print(f"The relative angle between the two images is: {relative_angle:.2f} degrees.")
		else:
			print("Could not detect the disk or the blue dot in one of the images.")
		
	
	def find_disk_center(self):

		# Convert the image to grayscale
		gray_image = cv2.cvtColor(self.npImage, cv2.COLOR_BGR2GRAY)

		# Circle detection (to find the disk)
		circles = cv2.HoughCircles(gray_image, cv2.HOUGH_GRADIENT, dp=1.2, minDist=40,
								param1=100, param2=30, minRadius=15, maxRadius=25)
		
		if circles is not None:
			circles = np.round(circles[0, :]).astype("int")
			# We assume the first detected circle is the disk
			center_x, center_y, radius = circles[0]
			cv2.circle(self.npImage, (center_x,center_y), radius, (0, 255, 255), 3) # and circle outline
			print('x:', center_x)
			print('y:', center_y)
			self.np2image2pixmap(self.npImage, numpyAlso=True)

	
#end class MainWindow

if __name__ == '__main__':
	print( f"{_appFileName}: (version {_version}), path for images is: {myPath}" )
	print( f"{_appFileName}: Using Qt {QT_VERSION_STR}" )
	mainApp = QApplication(sys.argv)
	if (len(sys.argv) >= 2):
		fn = sys.argv[1]
		if not os.path.isfile(fn):
			fn = myPath + os.path.sep + fn   # alternative location
		if os.path.isfile(fn):
			mainWin = MainWindow(fName=fn)
		else:
			mainWin = MainWindow()
	else:
		mainWin = MainWindow()
	mainWin.show()
	sys.exit(mainApp.exec_())
	

*************************************************************************************************
findAngle.py

import cv2
import numpy as np
import math

def find_center_and_blue_dot(npImage):
    """Find the center of the disk and the position of the blue dot."""
    
    # Convert the image to grayscale
    gray_image = cv2.cvtColor(npImage, cv2.COLOR_BGR2GRAY)
    
    # Circle detection (to find the disk)
    circles = cv2.HoughCircles(gray_image, cv2.HOUGH_GRADIENT, dp=1.2, minDist=40,
                               param1=100, param2=30, minRadius=15, maxRadius=25)
    
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        # We assume the first detected circle is the disk
        center_x, center_y, radius = circles[0]
        cv2.circle(npImage, (center_x,center_y), radius, (0, 255, 255), 3) # and circle outline
        
    circles = cv2.HoughCircles(gray_image, cv2.HOUGH_GRADIENT, dp=1.2, minDist=20, param1=100, param2=25, minRadius=5, maxRadius=20)
    
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        # We assume the first detected circle is the blue dot
        blue_dot_x, blue_dot_y, radius = circles[0]
        cv2.circle(npImage, (blue_dot_x,blue_dot_y), radius, (0, 255, 255), 3) # and circle outline
        
        #print(center_x, center_y, blue_dot_x, blue_dot_y)
    else:
        circles = cv2.HoughCircles(gray_image, cv2.HOUGH_GRADIENT, dp=2.1, minDist=40, param1=30, param2=36, minRadius=5, maxRadius=9)
        circles = np.round(circles[0, :]).astype("int")
        # We assume the first detected circle is the blue dot
        blue_dot_x, blue_dot_y, radius = circles[0]
        cv2.circle(npImage, (blue_dot_x,blue_dot_y), radius, (0, 255, 255), 3) # and circle outline
            
    return (center_x, center_y), (blue_dot_x, blue_dot_y)

def calculate_angle(center, blue_dot):
    """Calculate the angle of the blue dot relative to 12 o'clock (vertical line)."""
    delta_x = blue_dot[0] - center[0]
    delta_y = blue_dot[1] - center[1]
    
    # Calculate the angle in radians (with respect to the Y axis, considering clock orientation)
    angle_rad = math.atan2(delta_y, delta_x)
    
    # Convert the angle to degrees and adjust so that 12 o'clock is 0 degrees
    angle_deg = math.degrees(angle_rad)
    if angle_deg < 0:
        angle_deg = 360 + angle_deg
    
    # Adjust so that the angle starts at 12 o'clock and increases clockwise
    angle_deg = (angle_deg + 90) % 360
    
    return angle_deg

def calculate_relative_angle(image1, image2):
    """Calculate the relative angle between the blue dot in two images."""
    
    # Find the center and the blue dot in the first image
    center1, blue_dot1 = find_center_and_blue_dot(image1)
    
    # Find the center and the blue dot in the second image
    center2, blue_dot2 = find_center_and_blue_dot(image2)
    
    if center1 is not None and blue_dot1 is not None and center2 is not None and blue_dot2 is not None:
        # We assume the centers are approximately the same, so we'll use just one
        angle1 = calculate_angle(center1, blue_dot1)
        angle2 = calculate_angle(center2, blue_dot2)
        
        #print('Angle 1:', angle1)
        #print('Angle 2:', angle2)

        # Draw lines from the center to the blue dot in both images
        cv2.line(image2, center1, blue_dot1, (0, 0, 255), 2)  # Red line for the first image
        cv2.line(image2, center2, blue_dot2, (0, 255, 0), 2)  # Green line for the second image

        # Calculate the angular difference between the two images
        if angle1 > angle2:
            relative_angle = 360 - abs(angle1 - angle2)
        else:
            relative_angle = abs(angle1 - angle2)
        
        return relative_angle, image1, image2
    else:
        return None, image1, image2

if __name__ == '__main__':
    # Load the two images
    image1 = cv2.imread('disk_initial.jpg')
    image2 = cv2.imread('disk_trigger.jpg')

    # Calculate the angle between the two images
    relative_angle, image1_with_line, image2_with_line = calculate_relative_angle(image1, image2)

    # Show the images with the angle lines
    cv2.imshow("Image 1 with Angle Line", image1_with_line)
    cv2.imshow("Image 2 with Angle Line", image2_with_line)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    if relative_angle is not None:
        print(f"The relative angle between the two images is: {relative_angle:.2f} degrees.")
    else:
        print("Could not detect the disk or the blue dot in one of the images.")

