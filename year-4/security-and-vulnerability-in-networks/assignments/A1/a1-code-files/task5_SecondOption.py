import time
import matplotlib.pyplot as plt
import random
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import base64

# Transposition function
def transposition_encrypt(plaintext, key):
    # Ensure the plaintext length is divisible by the key length
    while len(plaintext) % len(key) != 0:
        plaintext += ' '

    # Create a matrix based on the key length
    n = len(key)
    matrix = [plaintext[i:i+n] for i in range(0, len(plaintext), n)]

    # Create transposed text based on key order
    sorted_key = sorted(list(key))
    transposed_text = ''
    for k in sorted_key:
        column_index = key.index(k)
        for row in matrix:
            transposed_text += row[column_index]

    return transposed_text

# Caesar cipher encryption function
def caesar_cipher_encrypt(plaintext, shift):
    encrypted_text = ''
    for char in plaintext:
        if char.isalpha():  # Encrypt letters only
            shift_amount = 65 if char.isupper() else 97
            encrypted_text += chr((ord(char) - shift_amount + shift) % 26 + shift_amount)
        else:
            encrypted_text += char  # Leave other characters unchanged

    return encrypted_text

# AES encryption with CBC mode
def aes_encrypt(plaintext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_plaintext = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded_plaintext)
    return base64.b64encode(ciphertext).decode('utf-8')

# Convert base64 encoded text to bytes, then to binary string
def text_to_binary2(text):
    return ''.join(format(byte, '08b') for byte in base64.b64decode(text))

# Calculate the avalanche effect between two binary strings
def calculate_avalanche_effect(bin1, bin2):
    differing_bits = sum(bit1 != bit2 for bit1, bit2 in zip(bin1, bin2))
    total_bits = len(bin1)
    return (differing_bits / total_bits) * 100 # The percentage of differing bits between the two binary strings

# AES encryption analysis with CBC
def repeated_encryption_analysis4(original_plaintext, modified_plaintext, key, rounds=16):
    avalanche_results = []
    prev_original_text = original_plaintext
    prev_modified_text = modified_plaintext
    for i in range(1, rounds + 1):
        start_time = time.time()
        iv = get_random_bytes(16) # Update the Random Initialization Vector (IV) with each iteration
        # Encrypt original and modified plaintext
        original_ciphertext = aes_encrypt(prev_original_text, key, iv)
        modified_ciphertext = aes_encrypt(prev_modified_text, key, iv)
        # Convert to binary
        original_binary = text_to_binary2(original_ciphertext)
        modified_binary = text_to_binary2(modified_ciphertext)
        # Calculate avalanche effect
        avalanche_effect = calculate_avalanche_effect(original_binary, modified_binary)
        computation_time = time.time() - start_time
        # Reload 
        prev_original_text = original_ciphertext
        prev_modified_text = modified_ciphertext
        
        # Store results for each round
        avalanche_results.append((i, avalanche_effect, computation_time))
        print(f"Round {i}: Avalanche Effect = {avalanche_effect:.2f}%, Time = {computation_time:.4f} seconds")

    return avalanche_results

# Entry data
original_plaintext = "Anton Maestre Security and Vulnerability in Networks"
modified_plaintext = "Antun Maestre Security and Vulnerability in Networks"  # Change one character in the string
aes_key = get_random_bytes(16)  # 128-bit AES key

# Perform the AES encryption analysis 
avalanche_results = repeated_encryption_analysis4(original_plaintext, modified_plaintext, aes_key, rounds=16)

# Creation of the graphs based on the results.
input("Press Enter for plotting...")

# Separate the data for plotting.
rounds = [result[0] for result in avalanche_results]
avalanche_effects = [result[1] for result in avalanche_results]
computation_times = [result[2] for result in avalanche_results]

# Plot Avalanche Effect vs. Rounds
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(rounds, avalanche_effects, marker='o', color='b', label='Avalanche Effect (%)')
plt.title('Avalanche Effect vs. Rounds')
plt.xlabel('Number of Rounds')
plt.ylabel('Avalanche Effect (%)')
plt.grid(True)

# Plot Computation Time vs. Rounds
plt.subplot(1, 2, 2)
plt.plot(rounds, computation_times, marker='o', color='r', label='Computation Time (s)')
plt.title('Computation Time vs. Rounds')
plt.xlabel('Number of Rounds')
plt.ylabel('Time (s)')
plt.grid(True)

plt.tight_layout()
plt.show()