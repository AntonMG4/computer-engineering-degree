import time

# Transposition function
def transposition_encrypt(plaintext, key):
    # Ensure the plaintext length is divisible by the key length
    while len(plaintext) % len(key) != 0:
        plaintext += ' '

    # Create a matrix based on the key length
    n = len(key)
    matrix = [plaintext[i:i+n] for i in range(0, len(plaintext), n)]

    # Create transposed text based on key order
    sorted_key = sorted(list(key))
    transposed_text = ''
    for k in sorted_key:
        column_index = key.index(k)
        for row in matrix:
            transposed_text += row[column_index]

    return transposed_text

# Caesar cipher encryption function
def caesar_cipher_encrypt(plaintext, shift):
    encrypted_text = ''
    for char in plaintext:
        if char.isalpha():  # Encrypt letters only
            shift_amount = 65 if char.isupper() else 97
            encrypted_text += chr((ord(char) - shift_amount + shift) % 26 + shift_amount)
        else:
            encrypted_text += char  # Leave other characters unchanged

    return encrypted_text

# Convert a string of text into a binary string representation.
def text_to_binary1(text):
    return ''.join(format(ord(char), '08b') for char in text)

# Calculate the avalanche effect between two binary strings
def calculate_avalanche_effect(bin1, bin2):
    differing_bits = sum(bit1 != bit2 for bit1, bit2 in zip(bin1, bin2))
    total_bits = len(bin1)
    return (differing_bits / total_bits) * 100 # The percentage of differing bits between the two binary strings

# Encryption function based on Transposition and Caesar cipher
def repeated_encryption_analysis1(original_plaintext, modified_plaintext, transposition_key, caesar_shift, rounds=16):
    avalanche_results = []
    start_time = time.time()

    for i in range(1, rounds + 1):

        original_text = original_plaintext
        modified_text = modified_plaintext

        # Apply encryption i times
        for _ in range(i):
            original_transposed = transposition_encrypt(original_text, transposition_key)
            original_text = caesar_cipher_encrypt(original_transposed, caesar_shift)

            modified_transposed = transposition_encrypt(modified_text, transposition_key)
            modified_text = caesar_cipher_encrypt(modified_transposed, caesar_shift)

        # Convert ciphertexts to binary
        original_binary = text_to_binary1(original_text)
        modified_binary = text_to_binary1(modified_text)

        # Calculate the avalanche effect
        avalanche_effect = calculate_avalanche_effect(original_binary, modified_binary)
        computation_time = time.time() - start_time

        # Store the results for this round
        avalanche_results.append((i, avalanche_effect, computation_time))

        print(f"Round {i}: Avalanche Effect = {avalanche_effect:.2f}%, Time = {computation_time:.4f} seconds")

    return avalanche_results

# Entry data
original_plaintext = "Anton Maestre Security and Vulnerability in Networks"
modified_plaintext = "Antun Maestre Security and Vulnerability in Networks"  # Change one character in the string
transposition_key = "34512"  # Transposition key
caesar_shift = 1  # Caesar cipher 

# Calculate the avalanche effect for a single round (Step 1)
original_transposed = transposition_encrypt(original_plaintext, transposition_key)
original_ciphertext = caesar_cipher_encrypt(original_transposed, caesar_shift)

modified_transposed = transposition_encrypt(modified_plaintext, transposition_key)
modified_ciphertext = caesar_cipher_encrypt(modified_transposed, caesar_shift)

print("Original plain text: ", original_plaintext)
print("Original transposed text: ", original_transposed)
print("Original ciphertext: ", original_ciphertext)
print("\nModified plain text: ", modified_plaintext)
print("Modified transposed text: ", modified_transposed)
print("Modified ciphertext: ", modified_ciphertext)

original_binary = text_to_binary1(original_ciphertext)
modified_binary = text_to_binary1(modified_ciphertext)

avalanche_effect = calculate_avalanche_effect(original_binary, modified_binary)
print(f"\nAvalanche Effect (Single Round): {avalanche_effect:.2f}% difference in bits\n")

# Perform the full analysis with multiple rounds (Step 2)
avalanche_results = repeated_encryption_analysis1(original_plaintext, modified_plaintext, transposition_key, caesar_shift, rounds=16)