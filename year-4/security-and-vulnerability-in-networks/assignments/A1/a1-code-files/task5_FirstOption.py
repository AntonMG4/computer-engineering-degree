import time
import matplotlib.pyplot as plt
import random

# Transposition function
def transposition_encrypt(plaintext, key):
    # Ensure the plaintext length is divisible by the key length
    while len(plaintext) % len(key) != 0:
        plaintext += ' '

    # Create a matrix based on the key length
    n = len(key)
    matrix = [plaintext[i:i+n] for i in range(0, len(plaintext), n)]

    # Create transposed text based on key order
    sorted_key = sorted(list(key))
    transposed_text = ''
    for k in sorted_key:
        column_index = key.index(k)
        for row in matrix:
            transposed_text += row[column_index]

    return transposed_text

# Caesar cipher encryption function
def caesar_cipher_encrypt(plaintext, shift):
    encrypted_text = ''
    for char in plaintext:
        if char.isalpha():  # Encrypt letters only
            shift_amount = 65 if char.isupper() else 97
            encrypted_text += chr((ord(char) - shift_amount + shift) % 26 + shift_amount)
        else:
            encrypted_text += char  # Leave other characters unchanged

    return encrypted_text

# XOR function to chain blocks
def xor_blocks(block1, block2):
    return ''.join(chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(block1, block2))

# Convert a string of text into a binary string representation.
def text_to_binary1(text):
    return ''.join(format(ord(char), '08b') for char in text)

# Calculate the avalanche effect between two binary strings
def calculate_avalanche_effect(bin1, bin2):
    differing_bits = sum(bit1 != bit2 for bit1, bit2 in zip(bin1, bin2))
    total_bits = len(bin1)
    return (differing_bits / total_bits) * 100 # The percentage of differing bits between the two binary strings

# Combined encryption with CBC applied to transposition + Caesar cipher
def combined_encryption_cbc(plaintext, transposition_key, caesar_shift, iv):
    block_size = len(iv)
    ciphertext = []
    
    # Break plaintext into blocks
    blocks = [plaintext[i:i+block_size] for i in range(0, len(plaintext), block_size)]
    
    prev_block = iv  # Use IV as the first "previous block"
    
    for block in blocks:
        # Apply XOR with the previous block (CBC mechanism)
        block = xor_blocks(block.ljust(block_size), prev_block)
        
        # Apply the combined transposition + Caesar cipher
        transposed_block = transposition_encrypt(block, transposition_key)
        encrypted_block = caesar_cipher_encrypt(transposed_block, caesar_shift)
        
        # Update the previous block with the current ciphertext block
        prev_block = encrypted_block
        ciphertext.append(encrypted_block)
    
    return ''.join(ciphertext)

# Function for repeated encryption analysis with CBC
def repeated_encryption_analysis3(original_plaintext, modified_plaintext, transposition_key, caesar_shift, iv, rounds=16):
    avalanche_results = []
    original_text = original_plaintext
    modified_text = modified_plaintext
    for i in range(1, rounds + 1):
        start_time = time.time()

        # Encrypt with CBC
        original_text = combined_encryption_cbc(original_text, transposition_key, caesar_shift, iv)
        modified_text = combined_encryption_cbc(modified_text, transposition_key, caesar_shift, iv)

        # Calculate avalanche effect
        original_binary = text_to_binary1(original_text)
        modified_binary = text_to_binary1(modified_text)

        avalanche_effect = calculate_avalanche_effect(original_binary, modified_binary)
        computation_time = time.time() - start_time

        # Store results for each round
        avalanche_results.append((i, avalanche_effect, computation_time))
        print(f"Round {i}: Avalanche Effect = {avalanche_effect:.2f}%, Time = {computation_time:.4f} seconds")

    return avalanche_results

# Entry data
original_plaintext = "Anton Maestre Security and Vulnerability in Networks"
modified_plaintext = "Antun Maestre Security and Vulnerability in Networks"  # Change one character in the string
transposition_key = "34512"  # Transposition key
caesar_shift = 1  # Caesar cipher 
iv = ''.join(random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ') for _ in range(8))  # Random initialization vector (IV)

# Perform the transposition-substitution in CBC mode encryption analysis 
avalanche_results = repeated_encryption_analysis3(original_plaintext, modified_plaintext, transposition_key, caesar_shift, iv, rounds=16)
            
# Creation of the graphs based on the results.
input("Press Enter for plotting...")

# Separate the data for plotting.
rounds = [result[0] for result in avalanche_results]
avalanche_effects = [result[1] for result in avalanche_results]
computation_times = [result[2] for result in avalanche_results]

# Plot Avalanche Effect vs. Rounds
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(rounds, avalanche_effects, marker='o', color='b', label='Avalanche Effect (%)')
plt.title('Avalanche Effect vs. Rounds')
plt.xlabel('Number of Rounds')
plt.ylabel('Avalanche Effect (%)')
plt.grid(True)

# Plot Computation Time vs. Rounds
plt.subplot(1, 2, 2)
plt.plot(rounds, computation_times, marker='o', color='r', label='Computation Time (s)')
plt.title('Computation Time vs. Rounds')
plt.xlabel('Number of Rounds')
plt.ylabel('Time (s)')
plt.grid(True)

plt.tight_layout()
plt.show()