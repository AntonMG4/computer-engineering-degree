import random
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import base64
import hashlib

# Step 1: Agree on public parameters
p = 23  # A large prime number
g = 5   # A primitive root modulo p

# Step 2: Alice and Bob generate private keys
a = random.randint(1, p-1)  # Alice's private key
b = random.randint(1, p-1)  # Bob's private key

# Step 3: Compute public keys
A = pow(g, a, p)  # Alice's public key
B = pow(g, b, p)  # Bob's public key

# Step 4: Exchange public keys and compute shared secret
shared_secret_Alice = pow(B, a, p)  # Alice computes the shared secret
shared_secret_Bob = pow(A, b, p)    # Bob computes the shared secret

# Both shared_secret_Alice and shared_secret_Bob should be the same
assert shared_secret_Alice == shared_secret_Bob

print(f"Alice's public key: {A}")
print(f"Bob's public key: {B}")
print(f"Shared secret: {shared_secret_Alice}")

# Convert shared secret to bytes (to use it as a key for HMAC)
shared_secret = str(shared_secret_Alice).encode()

# HMAC-SHA256 implementation for chain key ratcheting
def hmac_sha256(key, message):
    #return hashlib.sha256(key + message.encode()).digest()
    """
    This function computes HMAC using SHA-256.
    
    Parameters:
    - key: The secret key (derived from the Diffie-Hellman shared secret).
    - message: The message to be authenticated.
    
    Returns:
    - The HMAC tag as a hexadecimal string.
    """
    block_size = 64  # Block size for SHA-256 is 64 bytes
    
    # If key is longer than block size, hash it
    if len(key) > block_size:
        key = hashlib.sha256(key).digest()
    
    # Pad the key to block size
    key = key.ljust(block_size, b'\x00')
    
    # Define opad and ipad
    opad = bytes((x ^ 0x5c) for x in key)
    ipad = bytes((x ^ 0x36) for x in key)
    
    # Perform HMAC operation: HMAC(K, m) = hash((K' ⊕ opad) ∥ hash((K' ⊕ ipad) ∥ m))
    inner_hash = hashlib.sha256(ipad + message.encode()).digest()
    return hashlib.sha256(opad + inner_hash).digest()

# AES encryption with CBC mode
def aes_encrypt(plaintext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_plaintext = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded_plaintext)
    return base64.b64encode(ciphertext).decode('utf-8')

# AES decryption with CBC mode
def aes_decrypt(ciphertext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decoded_ciphertext = base64.b64decode(ciphertext)
    plaintext = unpad(cipher.decrypt(decoded_ciphertext), AES.block_size)
    return plaintext.decode('utf-8')

# Single Ratchet mechanism for chain key management
class SingleRatchet:
    def __init__(self, initial_chain_key):
        self.chain_key = initial_chain_key
    
    # Ratchet the chain key using HMAC
    def ratchet_chain_key(self):
        self.chain_key = hmac_sha256(self.chain_key, "ratchet")
        return self.chain_key
    
    # Derive a new message key from the chain key
    def derive_message_key(self):
        return hmac_sha256(self.chain_key, "message")[:16]  # Use the first 16 bytes for AES-128

# Initialize the Single Ratchet mechanism with the shared secret
alice_ratchet = SingleRatchet(shared_secret)
bob_ratchet = SingleRatchet(shared_secret)

# Testing the Single Ratchet for encryption and decryption
def ratchet_encryption_decryption_test():
    messages = ["Hello, Bob!", "What's up Alice?", "Are you having a good time?", 
                "Yes! I'll tell you when we see each other.", "Great! I'll be waiting for you", "See you soon"]
    
    for i in range(6):  # Run for 6 rounds to simulate multiple messages
        print(f"\nRound {i + 1}:")
        
        print(f"\nOriginal message: {messages[i]}\n")
        if i % 2 == 0:
            # Alice ratchets the chain key and derives a new message key
            alice_chain_key = alice_ratchet.ratchet_chain_key()
            alice_message_key = alice_ratchet.derive_message_key()
            iv = get_random_bytes(16)  # New IV for each round

            print(f"Alice's new chain key: {alice_chain_key.hex()}")

            # Combine the message and hmac_tag
            hmac_tag = hmac_sha256(alice_chain_key, messages[i])
            plaintext = messages[i]+hmac_tag.hex()

            # Alice encrypts the message
            ciphertext = aes_encrypt(plaintext, alice_message_key, iv)
            print(f"Encrypted ciphertext: {ciphertext}")
            
            # Bob ratchets his chain key to stay in sync with Alice
            bob_chain_key = bob_ratchet.ratchet_chain_key()
            bob_message_key = bob_ratchet.derive_message_key()
            print(f"\nBob's new chain key: {bob_chain_key.hex()}")
            # Bob decrypts the message
            decrypted_message = aes_decrypt(ciphertext, bob_message_key, iv)
            print(f"Decrypted ciphertext: {decrypted_message}")

        else:
            # Bob ratchets the chain key and derives a new message key
            bob_chain_key = bob_ratchet.ratchet_chain_key()
            bob_message_key = bob_ratchet.derive_message_key()
            iv = get_random_bytes(16)  # New IV for each round

            print(f"Bob's new chain key: {bob_chain_key.hex()}")

            # Combine the message and hmac_tag
            hmac_tag = hmac_sha256(bob_chain_key, messages[i])
            plaintext = messages[i]+hmac_tag.hex()

            # Bob encrypts the message
            ciphertext = aes_encrypt(plaintext, bob_message_key, iv)
            print(f"Encrypted ciphertext: {ciphertext}")
            
            # Alice ratchets his chain key to stay in sync with Bob
            alice_chain_key = alice_ratchet.ratchet_chain_key()
            alice_message_key = alice_ratchet.derive_message_key()
            print(f"\nAlice's new chain key: {alice_chain_key.hex()}")
            # Alice decrypts the message
            decrypted_message = aes_decrypt(ciphertext, alice_message_key, iv)
            print(f"Decrypted ciphertext: {decrypted_message}")

        # Separate the original message and HMAC
        original_message = decrypted_message[:-64]  # Assuming HMAC is 64 hex characters (32 bytes)
        received_hmac_tag = decrypted_message[-64:]  # The last part is the HMAC
        print(f"Decrypted message: {original_message}")

        if i % 2 == 0:
            hmac_tag2 = hmac_sha256(bob_chain_key, original_message)
        else:
            hmac_tag2 = hmac_sha256(alice_chain_key, original_message)

        # Checks the authenticity of the message
        assert received_hmac_tag == hmac_tag2.hex(), "The hmac is not the same!"
        
        # Ensure that the decrypted message matches the original
        assert original_message == messages[i], "Decrypted message does not match the original!"

        # Ensure that Alice and Bob's chain keys are synchronized
        assert alice_chain_key == bob_chain_key, "Alice and Bob's chain keys are out of sync!"
        
# Run the test for Single Ratchet encryption and decryption
ratchet_encryption_decryption_test()
