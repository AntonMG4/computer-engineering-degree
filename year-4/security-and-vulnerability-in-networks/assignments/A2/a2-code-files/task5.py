import random
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import base64
import hashlib

# Diffie-Hellman Key Exchange
def dh_generate_key_pair(p, g):
    private_key = random.randint(1, p-1)
    public_key = pow(g, private_key, p)
    return private_key, public_key

def dh_compute_shared_secret(their_public_key, my_private_key, p):
    return pow(their_public_key, my_private_key, p)

# HMAC-SHA256 implementation for chain key ratcheting and DH key updates
def hmac_sha256(key, message):
    block_size = 64  # Block size for SHA-256 is 64 bytes
    
    # If key is longer than block size, hash it
    if len(key) > block_size:
        key = hashlib.sha256(key).digest()
    
    # Pad the key to block size
    key = key.ljust(block_size, b'\x00')
    
    # Define opad and ipad
    opad = bytes((x ^ 0x5c) for x in key)
    ipad = bytes((x ^ 0x36) for x in key)
    
    # Perform HMAC operation: HMAC(K, m) = hash((K' ⊕ opad) ∥ hash((K' ⊕ ipad) ∥ m))
    if isinstance(message, bytes):
        inner_hash = hashlib.sha256(ipad + message).digest()
    else:
        inner_hash = hashlib.sha256(ipad + message.encode()).digest()
    return hashlib.sha256(opad + inner_hash).digest()

# AES encryption with CBC mode
def aes_encrypt(plaintext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_plaintext = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded_plaintext)
    return base64.b64encode(ciphertext).decode('utf-8')

# AES decryption with CBC mode
def aes_decrypt(ciphertext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decoded_ciphertext = base64.b64decode(ciphertext)
    plaintext = unpad(cipher.decrypt(decoded_ciphertext), AES.block_size)
    return plaintext.decode('utf-8')

# Double Ratchet mechanism for key management
class DoubleRatchet:
    def __init__(self, p, g, initial_dh_private, initial_dh_public, ppublic_key):
        self.dh_private = initial_dh_private
        self.dh_public = initial_dh_public
        self.p = p
        self.g = g
        self.ppublic_key = ppublic_key

        # Initialize keys
        self.shared_secret = dh_compute_shared_secret(self.ppublic_key, self.dh_private, self.p)
        self.root_key = hmac_sha256(str(self.shared_secret).encode(), "root")

        self.chain_key_send = hmac_sha256(self.root_key, "send")
        self.chain_key_reci = hmac_sha256(self.root_key, "receive")
    
    # Ratchet the chain keys using HMAC
    def ratchet_chain_key(self, private_key, public_key, ppublic_key):
        
        # Generate new shared secret
        self.ppublic_key = ppublic_key
        self.dh_private = private_key
        self.shared_secret = dh_compute_shared_secret(self.ppublic_key, self.dh_private, self.p)
        
        self.dh_public = public_key

        # Update root key
        self.root_key = hmac_sha256(self.root_key, str(self.shared_secret).encode())
        

        # New chain keys
        self.chain_key_send = hmac_sha256(self.root_key, "send")
        self.chain_key_reci = hmac_sha256(self.root_key, "receive")
        
    
    # Symmetric ratchet to derive the next message key
    def symmetric_ratchet_send(self):
        self.chain_key_send = hmac_sha256(self.chain_key_send, "ratchet")
        message_key = hmac_sha256(self.chain_key_send, "message")[:16]  # Use the first 16 bytes for AES-128
        return message_key

    def symmetric_ratchet_reci(self):
        self.chain_key_reci = hmac_sha256(self.chain_key_reci, "ratchet")
        message_key = hmac_sha256(self.chain_key_reci, "message")[:16]  # Use the first 16 bytes for AES-128
        return message_key
    
    # Sets the chain keys
    def set_chain_keys(self, send_key, recieve_key):
        self.chain_key_send = send_key
        self.chain_key_reci = recieve_key

# Initialize the Double Ratchet mechanism
p = 23  # A large prime number
g = 5   # A primitive root modulo p

# Step 1: Alice and Bob each generate initial DH key pair
alice_private, alice_public = dh_generate_key_pair(p, g)
bob_private, bob_public = dh_generate_key_pair(p, g)
print(f"First DH public key for Alice: {alice_public}")
print(f"First DH public key for Bob: {bob_public}")

# Initialize the Double Ratchet for Alice and Bob
alice_ratchet = DoubleRatchet(p, g, alice_private, alice_public, bob_public)
bob_ratchet = DoubleRatchet(p, g, bob_private, bob_public, alice_public)
print(f"First shared secret: {alice_ratchet.shared_secret}")
# Synchronize
bob_ratchet.set_chain_keys(alice_ratchet.chain_key_reci, alice_ratchet.chain_key_send)

# Testing Double Ratchet with proper DH key exchange
def double_ratchet_test():
    messages = ["Hello, Bob!", "What's up Alice?", "Are you having a good time?", 
                "Yes! I'll tell you when we see each other.", "Great! I'll be waiting for you", "See you soon"]
    
    for i in range(6):  # Run for 6 rounds to simulate multiple messages
        print(f"\nRound {i + 1}:")
        print(f"\nOriginal message: {messages[i]}\n")
        if i % 2 == 0:
            # Alice sends the message
            alice_message_key = alice_ratchet.symmetric_ratchet_send()
            iv = get_random_bytes(16)  # New IV for each round
            hmac_tag = hmac_sha256(alice_ratchet.chain_key_send, messages[i])
            plaintext = messages[i]+hmac_tag.hex()

            # Alice encrypts the message
            ciphertext = aes_encrypt(plaintext, alice_message_key, iv)
            print(f"Alice send chain key: {alice_ratchet.chain_key_send.hex()}")
            print(f"Encrypted ciphertext: {ciphertext}\n")
        
            # Bob receives the message
            bob_message_key = bob_ratchet.symmetric_ratchet_reci()
            print(f"Bob receive chain key: {bob_ratchet.chain_key_reci.hex()}")

            # Bob decrypts the message
            decrypted_message = aes_decrypt(ciphertext, bob_message_key, iv)
            print(f"Decrypted ciphertext: {decrypted_message}")
        else:
            # Bob sends the message
            bob_message_key = bob_ratchet.symmetric_ratchet_send()
            iv = get_random_bytes(16)  # New IV for each round
            hmac_tag = hmac_sha256(bob_ratchet.chain_key_send, messages[i])
            plaintext = messages[i]+hmac_tag.hex()

            # Bob encrypts the message
            ciphertext = aes_encrypt(plaintext, bob_message_key, iv)
            print(f"Bob send chain key: {bob_ratchet.chain_key_send.hex()}")
            print(f"Encrypted ciphertext: {ciphertext}\n")

            # Alice receives the message
            alice_message_key = alice_ratchet.symmetric_ratchet_reci()
            print(f"Alice receive chain key: {alice_ratchet.chain_key_reci.hex()}")

            # Alice decrypts the message
            decrypted_message = aes_decrypt(ciphertext, alice_message_key, iv)
            print(f"Decrypted ciphertext: {decrypted_message}")
            

        # Separate the original message and HMAC
        original_message = decrypted_message[:-64]  # Assuming HMAC is 64 hex characters (32 bytes)
        received_hmac_tag = decrypted_message[-64:]  # The last part is the HMAC
        
        if i % 2 == 0:
            hmac_tag2 = hmac_sha256(bob_ratchet.chain_key_reci, original_message)
            print(f"Bob's decrypted message: {original_message}")
        else:
            hmac_tag2 = hmac_sha256(alice_ratchet.chain_key_reci, original_message)
            print(f"Alice's decrypted message: {original_message}")
        
        # Checks the authenticity of the message
        assert received_hmac_tag == hmac_tag2.hex(), "The hmac is not the same!"

        # Ensure that the decrypted message matches the original
        assert messages[i] == original_message, "Decrypted message does not match the original!"
        
        # Every 3 rounds, perform a DH ratchet (key exchange)
        if (i + 1) % 3 == 0:
            print("\n...Performing DH ratchet (key exchange)...")
            
            # Step 1: Alice and Bob generate new DH key pairs
            alice_private, alice_public = dh_generate_key_pair(p, g)
            bob_private, bob_public = dh_generate_key_pair(p, g)
            
            alice_ratchet.ratchet_chain_key(alice_private, alice_public, bob_public)
            bob_ratchet.ratchet_chain_key(bob_private, bob_public, alice_public)

            # Swap the keys in one of them
            bob_ratchet.set_chain_keys(bob_ratchet.chain_key_reci, bob_ratchet.chain_key_send)

            print('\nAlice and Bob generate new DH key pairs\n')
            print('Alice:')
            print(f"New root key: {alice_ratchet.root_key.hex()}")
            print(f"New chain key send: {alice_ratchet.chain_key_send.hex()}")
            print(f"New chain key receive: {alice_ratchet.chain_key_reci.hex()}")

            print('\nBob:')
            print(f"New root key: {bob_ratchet.root_key.hex()}")
            print(f"New chain key send: {bob_ratchet.chain_key_send.hex()}")
            print(f"New chain key receive: {bob_ratchet.chain_key_reci.hex()}")

# Run the test for Double Ratchet encryption and decryption
double_ratchet_test()
