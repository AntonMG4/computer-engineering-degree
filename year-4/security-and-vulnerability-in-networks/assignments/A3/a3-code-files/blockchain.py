from block import Block
from wallet import Wallet
import time
import matplotlib.pyplot as plt

# Blockchain Class with Transaction Limit and Signature Verification
class Blockchain:

    def __init__(self, max_transactions_per_block=10, difficulty=3):
        self.unconfirmed_transactions = []  # Transactions to be mined
        self.chain = []  # List of blocks in the blockchain
        self.max_transactions_per_block = (
            max_transactions_per_block  # Max transactions per block
        )
        self.difficulty = difficulty
        self.create_genesis_block()  # Create the genesis block
        self.mining_times = []  # To store mining times for analysis

    def __str__(self):
        blockchain_summary = (
            f"Blockchain(length={len(self.chain)}, difficulty={self.difficulty})\n"
        )
        blockchain_summary += "Blocks:\n"
        for block in self.chain:
            blockchain_summary += f"  {block}\n"
        return blockchain_summary

    def create_genesis_block(self):
        """
        Generate the genesis block and add it to the chain.

        Steps:
        - Create a new Block with index 0, empty transactions, and previous_hash "0".
        - Compute the hash of the genesis block.
        - Append the genesis block to the chain.
        """
        genesis_block = Block(0, [], "0")
        genesis_block.hash = genesis_block.compute_hash()
        self.chain.append(genesis_block)

    @property
    def last_block(self):
        """
        Return the last block in the chain.
        """
        return self.chain[-1]

    def add_transaction(self, transaction):
        """
        Add a valid transaction to the list of unconfirmed transactions.

        Steps:
        - Verify if the transaction is valid by calling transaction.is_valid().
        - If valid, append it to unconfirmed_transactions and return True.
        - If invalid, return False.
        """
        if transaction.is_valid():
            self.unconfirmed_transactions.append(transaction)
            return True
        else:
            return False

    def proof_of_work(self, block):
        """
        Perform the proof-of-work algorithm to find a valid hash for the block.

        Steps:
        - Initialize the block's nonce to 0.
        - Compute the hash of the block.
        - While the hash does not start with the required number of zeros (based on difficulty):
            - Increment the nonce by 1.
            - Recompute the hash.
        - Once a valid hash is found, update the block's hash and return the hash.
        """
        # TODO: Implement the proof-of-work algorithm
        block.nonce = 0
        computed_hash = block.compute_hash()
        
        # Check if hash starts with the required number of zeros (based on difficulty)
        while not computed_hash.startswith("0" * self.difficulty):
            block.nonce += 1
            computed_hash = block.compute_hash()
        
        block.hash = computed_hash
        return computed_hash

    def add_block(self, block, proof):
        """
        Validate and add the block to the chain.

        Steps:
        - Get the hash of the last block and compare it with block.previous_hash.
          If they are not equal, return False.
        - Validate the proof by calling is_valid_proof(block, proof).
          If not valid, return False.
        - Append the block to the chain.
        - Return True to indicate success.
        """
        # TODO: Implement block validation and addition to the chain
        if block.previous_hash != self.last_block.hash:
            return False

        # Validate the proof
        if not self.is_valid_proof(block, proof):
            return False

        # Append the block to the chain
        self.chain.append(block)
        return True

    def is_valid_proof(self, block, block_hash):
        """
        Check if the block_hash is a valid hash of the block and satisfies the difficulty criteria.

        Steps:
        - Check if block_hash starts with the required number of zeros (based on difficulty).
        - Recompute the hash of the block and compare it with block_hash.
        - Return True if both conditions are met; otherwise, return False.
        """
        # TODO: Implement proof-of-work validation
        return block_hash.startswith("0" * self.difficulty) and block_hash == block.compute_hash()

    def mine(self):
        """
        Mine the unconfirmed transactions.

        Steps:
        - Check if there are unconfirmed transactions. If not, return False.
        - While there are transactions to be mined:
            - Select transactions up to max_transactions_per_block (if set).
            - Verify each transaction. If invalid, discard it.
            - Create a new Block with the selected transactions.
            - Perform proof of work to find a valid hash.
            - Add the block to the chain by calling add_block().
            - Remove the mined transactions from unconfirmed_transactions.
            - If max_transactions_per_block is None, break after mining one block.
        - Return the index of the last mined block.
        """
        # TODO: Implement the mining process
        if not self.unconfirmed_transactions:
            return False  # No transactions to mine

        # Select transactions up to the maximum per block limit
        transactions_to_mine = self.unconfirmed_transactions[:self.max_transactions_per_block]
        
        # Create a new block with selected transactions
        new_block = Block(
            index=self.last_block.index + 1,
            transactions=transactions_to_mine,
            previous_hash=self.last_block.hash
        )

        # Perform proof of work
        proof = self.proof_of_work(new_block)

        # Add the block to the chain
        if self.add_block(new_block, proof):
            # Remove mined transactions from unconfirmed transactions list
            self.unconfirmed_transactions = self.unconfirmed_transactions[self.max_transactions_per_block:]
            return new_block.index
        else:
            return False

    def is_chain_valid(self):
        """
        Validate the entire blockchain.

        Steps:
        - Iterate over the chain starting from the second block.
        - For each block:
            - Check if the block's hash matches its computed hash.
              If not, return False.
            - Check if the block's previous_hash matches the hash of the previous block.
              If not, return False.
            - Verify each transaction in the block by calling transaction.is_valid().
              If any transaction is invalid, return False.
        - If all checks pass, return True.
        """
        # TODO: Implement blockchain validation
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]

            # Check current block's hash
            if current_block.hash != current_block.compute_hash():
                return False

            # Check the previous hash reference
            if current_block.previous_hash != previous_block.hash:
                return False

            # Verify each transaction in the block
            for transaction in current_block.transactions:
                if not transaction.is_valid():
                    return False

        return True

    def is_transaction_in_block(self, transaction, block_index):
        # First, check if the block index is valid
        if block_index < 0 or block_index >= len(self.chain):
            return False

        # Retrieve the block by its index
        block = self.chain[block_index]

        # Use the `has_transaction` method of the Block class
        return block.has_transaction(transaction)

    def is_transaction_in_chain(self, transaction):
        # Check through every block in the chain
        for block in self.chain:
            if block.has_transaction(transaction):
                return True
        return False

    def mine_with_timing(self):
        """
        Mine the unconfirmed transactions while timing the process.

        Returns:
            Tuple containing the index of the mined block and the time taken.
        """
        if not self.unconfirmed_transactions:
            return False, 0  # No transactions to mine

        transactions_to_mine = self.unconfirmed_transactions[:self.max_transactions_per_block]
        new_block = Block(
            index=self.last_block.index + 1,
            transactions=transactions_to_mine,
            previous_hash=self.last_block.hash
        )

        start_time = time.time()  # Start timing
        proof = self.proof_of_work(new_block)
        mining_time = time.time() - start_time  # Calculate mining time
        self.mining_times.append((self.difficulty, mining_time))
        return True, mining_time;

    def experiment_mining_speed(self, difficulty_levels):
        """
        Conduct mining speed experiments with varying difficulty levels.

        Args:
            difficulty_levels: List of difficulty levels to test.
        """
        results = {}
        for difficulty in difficulty_levels:
            self.difficulty = difficulty  # Set the new difficulty
            print(f"Mining with difficulty: {difficulty}")
            its_mined, mining_time = self.mine_with_timing()
            results[difficulty] = mining_time
            print(f"Mined block: {its_mined}, Time taken: {mining_time:.4f} seconds")

        return results

    def plot_mining_results(self):
        """
        Plot the mining results using matplotlib.
        """
        difficulties = [entry[0] for entry in self.mining_times]
        times = [entry[1] for entry in self.mining_times]

        plt.figure(figsize=(10, 5))
        plt.plot(difficulties, times, marker='o')
        plt.title('Mining Time vs Difficulty')
        plt.xlabel('Difficulty Level')
        plt.ylabel('Time Taken (seconds)')
        plt.grid(True)
        plt.xticks(difficulties)  # Set x-ticks to be the difficulties
        plt.show()

    def measure_throughput(self, num_transactions, duration=10):
        """
        Measure the transaction rate (throughput) of the blockchain.

        Args:
            num_transactions: Total number of transactions to simulate.
            duration: Time duration in seconds to measure the throughput.

        Returns:
            The transaction rate (transactions per second).
        """
        # Create wallets for users
        users = {}
        for i in range(10):
            user_id = f"User_{i}"
            users[user_id] = Wallet()

        start_time = time.time()
        transactions_processed = 0
        
        # Simulate adding transactions
        for i in range(num_transactions):
            sender_id = f"User_{i % 10}"
            recipient_id = f"User_{(i + 1) % 10}"
            amount = i * 0.1
            sender_wallet = users[sender_id]
            recipient_wallet = users[recipient_id]

            transaction = sender_wallet.create_transaction(recipient_wallet.address, amount) # Create a new transaction
            if self.add_transaction(transaction):
                transactions_processed += 1
            
            # Mine the transactions periodically
            if len(self.unconfirmed_transactions) >= self.max_transactions_per_block:
                self.mine()  # Mine the block

            # Check if the duration has been exceeded
            if (time.time() - start_time) > duration:
                break

        end_time = time.time()
        total_time = end_time - start_time
        transaction_rate = transactions_processed / total_time if total_time > 0 else 0
            
        print(f"Max transactions per block ={self.max_transactions_per_block}")
        print(f"Processed {transactions_processed} transactions in {total_time:.2f} seconds.")
        print(f"Transaction rate: {transaction_rate:.2f} transactions per second.")
        return transaction_rate