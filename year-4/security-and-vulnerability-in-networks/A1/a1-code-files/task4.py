import time
import matplotlib.pyplot as plt

# Transposition function
def transposition_encrypt(plaintext, key):
    # Ensure the plaintext length is divisible by the key length
    while len(plaintext) % len(key) != 0:
        plaintext += ' '

    # Create a matrix based on the key length
    n = len(key)
    matrix = [plaintext[i:i+n] for i in range(0, len(plaintext), n)]

    # Create transposed text based on key order
    sorted_key = sorted(list(key))
    transposed_text = ''
    for k in sorted_key:
        column_index = key.index(k)
        for row in matrix:
            transposed_text += row[column_index]

    return transposed_text

# Vigenère cipher encryption function
def vigenere_cipher_encrypt(plaintext, key):
    key = key.upper()
    ciphertext = []
    key_index = 0
    plaintext2 = plaintext.upper().replace(' ', '')

    key_length = len(key)
    if len(plaintext) > key_length: # Fill the key with text from the plaintext.
        padding_length = len(plaintext) - key_length
        padding = plaintext2[:padding_length]
        key = key + padding
    else:
        key = key
    key = key.upper()
    
    for char in plaintext:
        if char.isalpha():
            shift = ord(key[key_index % len(key)]) - ord('A')  # Determine the shift based on the key
            if char.isupper():
                ciphertext.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A')))
            else:
                ciphertext.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a')))
            key_index += 1  # Move to the next character in the key
        else:
            ciphertext.append(char)  # Do not encrypt spaces or special characters
    return ''.join(ciphertext)


# Caesar cipher encryption function
def caesar_cipher_encrypt(plaintext, shift):
    encrypted_text = ''
    for char in plaintext:
        if char.isalpha():  # Encrypt letters only
            shift_amount = 65 if char.isupper() else 97
            encrypted_text += chr((ord(char) - shift_amount + shift) % 26 + shift_amount)
        else:
            encrypted_text += char  # Leave other characters unchanged

    return encrypted_text

# Convert a string of text into a binary string representation.
def text_to_binary1(text):
    return ''.join(format(ord(char), '08b') for char in text)

# Calculate the avalanche effect between two binary strings
def calculate_avalanche_effect(bin1, bin2):
    differing_bits = sum(bit1 != bit2 for bit1, bit2 in zip(bin1, bin2))
    total_bits = len(bin1)
    return (differing_bits / total_bits) * 100 # The percentage of differing bits between the two binary strings

# Combined encryption function (Transposition -> Vigenère -> Caesar)
def combined_encryption(plaintext, transposition_key, vigenere_key, caesar_shift, prev_ciphertext=None):
    # Step 1: Apply transposition
    transposed_text = transposition_encrypt(plaintext, transposition_key)
    
    # Step 2: Apply Vigenère
    vigenere_text = vigenere_cipher_encrypt(transposed_text, vigenere_key)
    
    # Step 3: Apply Caesar
    final_ciphertext = caesar_cipher_encrypt(vigenere_text, caesar_shift)
    
    return final_ciphertext

# Encryption function based on Transposition, Vigènere and Caesar cipher
def repeated_encryption_analysis2(original_plaintext, modified_plaintext, transposition_key, caesar_shift, vigenere_key, rounds=16):
    avalanche_results = []
    for i in range(1, rounds + 1):
        start_time = time.time()

        original_text = original_plaintext
        modified_text = modified_plaintext

        # Apply encryption i times
        for _ in range(i):
            original_text = combined_encryption(original_text, transposition_key, vigenere_key, caesar_shift)

            modified_text = combined_encryption(modified_text, transposition_key, vigenere_key, caesar_shift)

        # Convert the ciphertexts to binary
        original_binary = text_to_binary1(original_text)
        modified_binary = text_to_binary1(modified_text)

        # Calculate the avalanche effect
        avalanche_effect = calculate_avalanche_effect(original_binary, modified_binary)
        computation_time = time.time() - start_time

        # Store the results
        avalanche_results.append((i, avalanche_effect, computation_time))

        print(f"Round {i}:  Avalanche Effect = {avalanche_effect:.2f}%, Time = {computation_time:.4f} seconds")

    return avalanche_results

# Entry data
original_plaintext = "Anton Maestre Security and Vulnerability in Networks"
modified_plaintext = "Antun Maestre Security and Vulnerability in Networks"  # Change one character in the string
transposition_key = "34512"  # Transposition key
caesar_shift = 1  # Caesar cipher 
vigenere_key = "LONGKEYVIGENERE"  # Vigènere key

# Execute the analysis.
avalanche_results = repeated_encryption_analysis2(original_plaintext, modified_plaintext, transposition_key, caesar_shift, vigenere_key, rounds=16)

# Creation of the graphs based on the results.
input("Press Enter for plotting...")

# Separate the data for plotting.
rounds = [result[0] for result in avalanche_results]
avalanche_effects = [result[1] for result in avalanche_results]
computation_times = [result[2] for result in avalanche_results]

# Plot Avalanche Effect vs. Rounds
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(rounds, avalanche_effects, marker='o', color='b', label='Avalanche Effect (%)')
plt.title('Avalanche Effect vs. Rounds')
plt.xlabel('Number of Rounds')
plt.ylabel('Avalanche Effect (%)')
plt.grid(True)

# Plot Computation Time vs. Rounds
plt.subplot(1, 2, 2)
plt.plot(rounds, computation_times, marker='o', color='r', label='Computation Time (s)')
plt.title('Computation Time vs. Rounds')
plt.xlabel('Number of Rounds')
plt.ylabel('Time (s)')
plt.grid(True)

plt.tight_layout()
plt.show()

# Determine the optimal number of rounds based on a balance between avalanche effect and computation time
optimal_round = max(range(len(avalanche_effects)), key=lambda x: avalanche_effects[x] / (computation_times[x]+0.00000001))
            
print(f"Optimal number of rounds based on the balance: {optimal_round + 1}")
