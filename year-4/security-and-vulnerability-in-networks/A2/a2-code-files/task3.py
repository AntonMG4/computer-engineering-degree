import random
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import base64
import hashlib
import random

# Step 1: Agree on public parameters
p = 23  # A large prime number
g = 5   # A primitive root modulo p

# Step 2: Alice and Bob generate private keys
a = random.randint(1, p-1)  # Alice's private key
b = random.randint(1, p-1)  # Bob's private key

# Step 3: Compute public keys
A = pow(g, a, p)  # Alice's public key
B = pow(g, b, p)  # Bob's public key

# Step 4: Exchange public keys and compute shared secret
shared_secret_Alice = pow(B, a, p)  # Alice computes the shared secret
shared_secret_Bob = pow(A, b, p)    # Bob computes the shared secret

# Both shared_secret_Alice and shared_secret_Bob should be the same
assert shared_secret_Alice == shared_secret_Bob

print(f"Alice's public key: {A}")
print(f"Bob's public key: {B}")
print(f"Shared secret: {shared_secret_Alice}\n")
# Convert shared secret to bytes (to use it as a key for HMAC)
shared_secret = str(shared_secret_Alice).encode()

# HMAC with SHA-256 implementation
def hmac_sha256(key, message):
    """
    This function computes HMAC using SHA-256.
    
    Parameters:
    - key: The secret key (derived from the Diffie-Hellman shared secret).
    - message: The message to be authenticated.
    
    Returns:
    - The HMAC tag as a hexadecimal string.
    """
    block_size = 64  # Block size for SHA-256 is 64 bytes
    
    # If key is longer than block size, hash it
    if len(key) > block_size:
        key = hashlib.sha256(key).digest()
    
    # Pad the key to block size
    key = key.ljust(block_size, b'\x00')
    
    # Define opad and ipad
    opad = bytes((x ^ 0x5c) for x in key)
    ipad = bytes((x ^ 0x36) for x in key)
    
    # Perform HMAC operation: HMAC(K, m) = hash((K' ⊕ opad) ∥ hash((K' ⊕ ipad) ∥ m))
    inner_hash = hashlib.sha256(ipad + message).digest()
    return hashlib.sha256(opad + inner_hash).hexdigest()

# AES encryption with CBC mode
def aes_encrypt(plaintext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_plaintext = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded_plaintext)
    return base64.b64encode(ciphertext).decode('utf-8')

# AES decryption with CBC mode
def aes_decrypt(ciphertext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decoded_ciphertext = base64.b64decode(ciphertext)
    plaintext = unpad(cipher.decrypt(decoded_ciphertext), AES.block_size)
    return plaintext.decode('utf-8')

# Testing HMAC with SHA-256 using the Diffie-Hellman shared secret
message = b'Hello, Bob!'
hmac_tag1 = hmac_sha256(shared_secret, message)

print(f"Original message: {message.decode()}\n")
print(f"HMAC tag: {hmac_tag1}\n")

aes_key = get_random_bytes(16)  # 128-bit AES key
iv = get_random_bytes(16)  # Initialization Vector (IV)
plaintext = message.decode('utf-8')+hmac_tag1

print(f"Message + HMAC tag: {plaintext}\n")
# Encrypt the message
ciphertext = aes_encrypt(plaintext, aes_key, iv)

print(f"Encrypted plaintext: {ciphertext}\n")

# Decrypt the ciphertext
decrypted_plaintext = aes_decrypt(ciphertext, aes_key, iv)
original_message = decrypted_plaintext[:-64]
received_hmac_tag = decrypted_plaintext[-64:]
print(f"Decrypted message: {original_message}")
print(f"Decrypted HMAC: {received_hmac_tag}")

hmac_tag2 = hmac_sha256(shared_secret, original_message.encode('utf-8'))

# Authentication
assert received_hmac_tag == hmac_tag2