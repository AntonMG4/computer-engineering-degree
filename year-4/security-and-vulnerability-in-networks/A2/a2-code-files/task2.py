import random

# Step 1: Agree on public parameters
p = 23  # A large prime number
g = 5   # A primitive root modulo p

# Step 2: Alice and Bob generate private keys
a = random.randint(1, p-1)  # Alice's private key
b = random.randint(1, p-1)  # Bob's private key

# Step 3: Compute public keys
A = pow(g, a, p)  # Alice's public key
B = pow(g, b, p)  # Bob's public key

# Step 4: Exchange public keys and compute shared secret
shared_secret_Alice = pow(B, a, p)  # Alice computes the shared secret
shared_secret_Bob = pow(A, b, p)    # Bob computes the shared secret

# Both shared_secret_Alice and shared_secret_Bob should be the same
assert shared_secret_Alice == shared_secret_Bob

print(f"Alice's public key: {A}")
print(f"Bob's public key: {B}")
print(f"Shared secret: {shared_secret_Alice}\n")

# Convert shared secret to bytes (to use it as a key for HMAC)
shared_secret = str(shared_secret_Alice).encode()

# XOR-based HMAC Implementation
def xor_hash(data, block_size=64):
    """
    A simple XOR-based hash function.
    
    Parameters:
    - data: The input message or key to be hashed.
    - block_size: The block size used in the HMAC (64 bytes by default).
    
    Returns:
    - A simple hash of the data using XOR.
    """
    hash_value = bytearray(block_size)
    
    # XOR each byte of the input data
    for i in range(len(data)):
        hash_value[i % block_size] ^= data[i]
    
    return bytes(hash_value)

# HMAC using XOR-based hash
def hmac_xor(key, message, block_size=64):
    """
    HMAC implementation using a XOR-based hash function.
    
    Parameters:
    - key: The secret key.
    - message: The message to be authenticated.
    - block_size: The block size (64 bytes by default).
    
    Returns:
    - The HMAC tag computed using the XOR-based hash.
    """
    # If key is longer than block size, hash it
    if len(key) > block_size:
        key = xor_hash(key, block_size)
    
    # Pad the key to block size
    key = key.ljust(block_size, b'\x00')
    
    # Define opad and ipad
    opad = bytes((x ^ 0x5c) for x in key)
    ipad = bytes((x ^ 0x36) for x in key)
    
    # Perform the HMAC operation: HMAC(K, m) = hash((K' ⊕ opad) ∥ hash((K' ⊕ ipad) ∥ m))
    inner_hash = xor_hash(ipad + message, block_size)
    return xor_hash(opad + inner_hash, block_size)

# Testing HMAC with XOR-based hash using the Diffie-Hellman shared secret
message = b'Hello dear friend'
hmac_tag = hmac_xor(shared_secret, message)

print(f"Original message: {message.decode()}\n")
print(f"HMAC tag: {hmac_tag.hex()}")
